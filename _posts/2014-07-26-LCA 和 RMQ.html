---
layout: post
title: "LCA 和 RMQ"
category: "算法"
---

<div style="line-height: 1.5; color: #2c3f51;">
<div></div>
<div>
</div><div>

<p style="margin: 0 0 1.1em;"></p>
<div><div>
<ul style="margin-top: 0; margin-bottom: 15px; list-style-type: none;">
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">LCA 和 RMQ</a><ul style="margin-top: 0; margin-bottom: 15px; list-style-type: none;">
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">1. 转换成链表交点问题</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">2. 利用 DFS 转换成 RMQ (在线)</a><ul style="margin-top: 0; margin-bottom: 15px; list-style-type: none;">
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">Sparse Table 算法</a><ul style="margin-top: 0; margin-bottom: 15px; list-style-type: none;">
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">预处理</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">查询</a></li>
</ul>
</li>
</ul>
</li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">3. Tarjan 算法 (离线)</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p style="margin: 0 0 1.1em;">这篇文章主要谈谈 LCA (lowest common ancestor) ，即最近公共祖先问题的常见解法。</p></div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">1. 转换成链表交点问题</h2>
<p style="margin: 0 0 1.1em;">如果节点 i/j 内维护父节点的指针，则可以很容易地找到 i/j 到根节点的路径，问题变成了求两条链表在何处相交：</p>
<p style="margin: 0 0 1.1em;"><img alt="Alt text" class="en-media" longdesc="./1407323589036.png" name="1fb112fe-6ade-4798-8fa9-f8ed0ad487b7" src="/assets/img/4a09fbd87ff48a48bd85f4fdcda880bb.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;">上图中，7 和 10 的 LCA 即为 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">7-3-1</code> 与 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">10-8-3-1</code> 两条链表的交点 3。</p>
<p style="margin: 0 0 1.1em;">链表交点可以这样求：</p>
<p style="margin: 0 0 1.1em;">遍历得到两条链表长度之差 m，再用两个指针分别指向两个 head，让长链表的那个指针先走 m 步，然后两个指针同时移动，直到指向同一个节点，该节点即为交点，如下图所示：</p>
<p style="margin: 0 0 1.1em;"><img alt="Alt text" class="en-media" longdesc="./1407324604832.png" name="339e0b7c-28b6-4553-864d-bc3f22537385" src="/assets/img/d37b5c703d331ae31aa0abb0221c878c.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">2. 利用 DFS 转换成 RMQ (在线)</h2>
<p style="margin: 0 0 1.1em;">该算法的基本原理是，如果把一棵树 DFS 走过的路径 Path 记录下来（包括回溯时经过的节点），对于两个节点 i 和 j ，找到他们第一次出现在 Path 的位置，这之间的序列就表示 DFS 过程中从节点 i 出发访问到 j 的轨迹，其中，高度最低的节点即为二者的 LCA。</p>
<p style="margin: 0 0 1.1em;">以下图为例</p>
<p style="margin: 0 0 1.1em;"><img alt="Alt text" class="en-media" longdesc="./1407327658433.png" name="505d9cd6-d28b-4a18-a043-c8e14d261be9" src="/assets/img/3b12ff933815c334ced1d619745e3d91.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;">DFS路径如下：</p>
</div><div>
<pre style="font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;" xml:space="preserve"><code style="font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;"><span style="color: #ae81ff;">1</span>  <span style="color: #ae81ff;">2</span>  <span style="color: #ae81ff;">1</span>  <span style="color: #ae81ff;">3</span>  <span style="color: #ae81ff;">4</span>  <span style="color: #ae81ff;">9</span>  <span style="color: #ae81ff;">4</span>  *<span style="color: #ae81ff;">3</span>*  <span style="color: #ae81ff;">5</span>
               ￣         ￣</code></pre>
<p style="margin: 0 0 1.1em;">9 到 5 的轨迹为 9-4-3-5，其中 3 最矮，它就是 9 和 5 的 LCA。</p>
<p style="margin: 0 0 1.1em;">实现上述逻辑需要两个数据结构：</p>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li><p style="margin: 0 0 1.1em;">DFS 路径 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">path</code>，每个元素还得额外保存节点高度；</p>
<p style="margin: 0 0 1.1em;">对一棵二叉树而言，每个节点在 DFS 的过程中最多出现两次，因此 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">path</code> 的长度最多为 2n。</p></li>
<li>一个 map <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">firstOccur</code>，保存每个节点在<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">path</code>中第一次出现的位置。</li>
</ol>
<p style="margin: 0 0 1.1em;">于是问题转换为 RMQ。对 RMQ，<a href="http://novoland.github.io/算法/2014/07/26/线段树.html" style="background: transparent; color: #1980e6; text-decoration: none;" target="_blank">线段树</a>是一种可行的解法，它需要 <span><span></span><span style="font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;"></span></span> 的建树时间，<span><span></span><span style="font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;"></span></span> 的查询时间。</p>
<p style="margin: 0 0 1.1em;">这里介绍另一种基于动态规划，名为 <strong style="font-weight: bold;">Sparse Table</strong> 的算法。</p>
</div><div>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;">Sparse Table 算法</h3>
<p style="margin: 0 0 1.1em;">Sparse Table 算法用一个表格记录某些特定区间的最小值，任意区间都可以分解为其中的两个（可能重叠的）子区间。它需要 <span><span></span><span style="font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;"></span></span> 时间预处理，每次查询耗时 <span><span></span><span style="font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;"></span></span>；空间复杂度为 <span><span></span><span style="font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;"></span></span>。</p>
</div><div>
<h4 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;">预处理</h4>
<p style="margin: 0 0 1.1em;">首先需要一个矩阵 m，<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">m[i][j]</code>表示从索引 i 开始连续 <span><span></span><span style="font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;"></span></span> 个数，即区间 <span><span></span><span style="font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;"></span></span> 中的最小值。例如数列 a：</p>
</div><div>
<pre style="font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;" xml:space="preserve"><code style="font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;"><span style="color: #ae81ff;">3</span> <span style="color: #ae81ff;">2</span> <span style="color: #ae81ff;">4</span> <span style="color: #ae81ff;">5</span> <span style="color: #ae81ff;">6</span> <span style="color: #ae81ff;">8</span> <span style="color: #ae81ff;">1</span> <span style="color: #ae81ff;">2</span> <span style="color: #ae81ff;">9</span> <span style="color: #ae81ff;">7</span></code></pre>
<p style="margin: 0 0 1.1em;"><code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">m[0][0]</code> 表示从 0 开始，长度为 <span><span></span><span style="font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;"></span></span> 的最大值，即3；因此 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">m[i][0]</code> 就等于<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">a[i]</code>，这就是 DP 的初始状态，也即 DP 表格的第一列。</p>
<p style="margin: 0 0 1.1em;">接下来就是递推式了。由于<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">m[i][j]</code>代表的区间长度肯定是偶数，因此可以将其平均分成两段：</p>
</div><div>
<p style="margin: 0 0 1.1em;"></p><div><div style="text-align: center; margin: 1em 0; position: relative; display: block; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%;"><span style="font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;"><span><img class="en-media" height="19.25" longdesc="__SVG__453df6ebdd33e2ebd7673f762d4ae5a2" name="ae55c72d-cedd-4131-8bba-dba81c6a3a6c" src="/assets/img/ee948da471e50188a8cc33a9d208ffab" style="margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;" width="188.125"/></span></span></div></div>
<div><div style="text-align: center; margin: 1em 0; position: relative; display: block; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%;"><span style="font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;"><span><img class="en-media" height="19.25" longdesc="__SVG__7f18c6414192689b2237f688e56b3b42" name="20f70f6e-deff-4104-abf7-57032d7390f5" src="/assets/img/111097c7cb5f1c85fcb8b4a36a4246d4" style="margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;" width="267.75"/></span></span></div></div><p style="margin: 0 0 1.1em;"></p>
<p style="margin: 0 0 1.1em;">递推式也就出来了：</p>
</div><div>
<p style="margin: 0 0 1.1em;"></p><div><div style="text-align: center; margin: 1em 0; position: relative; display: block; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%;"><span style="font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;"><span><img class="en-media" height="19.25" longdesc="__SVG__b75eb5b96be606d93ac168e7a837799d" name="c1b67244-2dce-4e30-b326-1027f581c4a8" src="/assets/img/66174b2e2dd40d764314f6d4180bf4c1" style="margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;" width="300.125"/></span></span></div></div><p style="margin: 0 0 1.1em;"></p>
<p style="margin: 0 0 1.1em;">这个 DP 是从左向右<em>一列一列</em>进行的。</p>
</div><div>
<h4 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;">查询</h4>
<p style="margin: 0 0 1.1em;">给定一个任意区间<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">[i,j]</code>，我们找到满足 <span><span></span><span style="font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;"></span></span>(区间内元素个数) 的最大的 k，则有:</p>
</div><div>
<p style="margin: 0 0 1.1em;"></p><div><div style="text-align: center; margin: 1em 0; position: relative; display: block; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%;"><span style="font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;"><span><img class="en-media" height="19.25" longdesc="__SVG__8747e21f9d6d687051494732e426ac4d" name="e40673bb-2346-4ad7-aa2a-3a192cf86774" src="/assets/img/91edbd460741ed1ee831fe8596d8d13f" style="margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;" width="287.875"/></span></span></div></div><p style="margin: 0 0 1.1em;"></p>
<p style="margin: 0 0 1.1em;">举个例子，对于区间 [3,9]，取 k = 2 ，m[3][2] 和 m[6][2] 将这7个元素划分为两个 <strong style="font-weight: bold;">重叠</strong> 的部分，靠左4个，靠右4个，最小值即为它们中最小的那个。</p>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">3. Tarjan 算法 (离线)</h2></div><div></div></div>