---
layout: post
title: "Java内存模型和Volatile"
category: "并发"
---

<div style="line-height: 1.5; color: #2c3f51;">
<div></div>
<div>
</div><div>

<p style="margin: 0 0 1.1em;"></p>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">1. 什么是 JMM？</h2>
<p style="margin: 0 0 1.1em;">JMM屏蔽掉底层不同平台的差异，在语言层面为程序员提供一个抽象的内存模型，它的核心是一系列关于<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">指令乱序</code>的规则，java语言层面上提供的<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">volatile</code>和<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">monitor机制</code>是其中的两个重点。</p>
<p style="margin: 0 0 1.1em;">有两个方面会导致指令的乱序执行：</p>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li><strong style="font-weight: bold;">编译器重排序</strong></li>
<li><strong style="font-weight: bold;">CPU 重排序</strong></li>
</ol>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">2. 编译器的重排序</h2>
<p style="margin: 0 0 1.1em;">编译器（对 java 而言是 JIT 编译器）在保证 <strong style="font-weight: bold;">单线程语义正确</strong> 的前提下，为了优化性能，可以任意对指令重新排序。这对单线程不会产生影响，但在并发环境下就可能导致问题。</p>
</div><div>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;">2.1 Compiler Memory Barrier</h3>
<p style="margin: 0 0 1.1em;">在其他未提供统一内存模型的语言中(如C)，需要使用<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Compiler Memory Barrier</code>显式告诉编译器停止重排序：以该Barrier为分割线，Barrier上方的指令不可以重排序到下方，反之亦然。</p>
<p style="margin: 0 0 1.1em;">C中，不同的编译器需要不同的指令：</p>
</div><div>
<pre style="font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;" xml:space="preserve"><code style="font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;">__asm__ __volatile__ (<span style="color: #e6db74;">""</span> ::: <span style="color: #e6db74;">"memory"</span>); <span style="color: #75715e;">// GNU</span>
__memory_barrier(); <span style="color: #75715e;">// Intel ECC Compiler</span>
_ReadWriteBarrier(); <span style="color: #75715e;">// Microsoft Visual C++</span></code></pre>
<p style="margin: 0 0 1.1em;">这些指令是针对编译器的，不会对CPU起作用。</p>
</div><div>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;">2.2 JMM 对编译器重排序的规定</h3>
<p style="margin: 0 0 1.1em;">JMM在为编译器重排序定义了如下规则（NO表示不可重排序）：</p>
<table style="border-collapse: collapse; border-spacing: 0; margin-bottom: 20px;">
<thead>
<tr>
<th style="padding: .5em; line-height: 1.5; vertical-align: bottom; border-top: 0; font-weight: bold; border: 1px solid #ddd;">1nd \\\ 2nd</th>
<th style="padding: .5em; line-height: 1.5; vertical-align: bottom; border-top: 0; font-weight: bold; border: 1px solid #ddd;">Normal Load / Normal Store</th>
<th style="padding: .5em; line-height: 1.5; vertical-align: bottom; border-top: 0; font-weight: bold; border: 1px solid #ddd;">Volatile Load / Monitor Enter</th>
<th style="padding: .5em; line-height: 1.5; vertical-align: bottom; border-top: 0; font-weight: bold; border: 1px solid #ddd;">Volatile Store / Monitor Exit</th>
</tr>
</thead>
<tbody><tr>
<td style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;">Normal Load / Normal Store</td>
<td style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;"></td>
<td style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;"></td>
<td style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;">NO</td>
</tr>
<tr>
<td style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;">Volatile Load / Monitor Enter</td>
<td style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;">NO</td>
<td style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;">NO</td>
<td style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;">NO</td>
</tr>
<tr>
<td style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;">Volatile store / Monitor Exit</td>
<td style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;"></td>
<td style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;">NO</td>
<td style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;">NO</td>
</tr>
</tbody></table>
<blockquote style="padding: 15px 20px; margin: 0 0 1.1em; border-left: 5px solid rgba(102,128,153,0.075); border-left-width: 10px; background-color: rgba(102,128,153,0.05); border-top-right-radius: 5px; border-bottom-right-radius: 5px;">
<p style="margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 0;"><code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Monitor Enter</code> 和 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Monitor Exit</code> 分别对应 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Sychronized</code> 块的进入和离开。</p>
</blockquote>
<p style="margin: 0 0 1.1em;">简单地说就是在3类地方禁止编译器重排序：</p>
<p style="margin: 0 0 1.1em;"><img alt="Alt text" class="en-media" longdesc="./1403762671001.png" name="d6e30d03-880d-4961-b607-eb924270f492" src="/assets/img/d08f4d58e9f50ecfc929b199829526c4.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li><code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Volatile 读</code> &amp; <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Sychronized 块的进入</code> 与 <strong style="font-weight: bold;">后续任意读写</strong> 不可重排；</li>
<li><code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Volatile 写</code> &amp; <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Sychronized 块的离开</code> 与 <strong style="font-weight: bold;">之前任意读写</strong> 不可重排；</li>
<li><code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Volatile 写</code> &amp; <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Sychronized 块的离开</code> 与后续 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Volatile 读</code> &amp; <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Sychronized 块的进入</code> 不可重排。</li>
</ol>
<p style="margin: 0 0 1.1em;">这几处和后面提到的 CPU指令重排序 是一致的。</p>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">3. CPU 重排序（<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Memory Reordering</code>）</h2>
<p style="margin: 0 0 1.1em;"><code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Memory Rerdering</code>指的是在 CPU 在执行程序时， 对内存地址的 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">load</code> 和 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">store</code> 指令 <strong style="font-weight: bold;">实际完成的顺序 与 发起指令的顺序 不一致</strong></p>
</div><div>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;">3.1 为什么会出现<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Memory Reordering</code>？</h3>
<p style="margin: 0 0 1.1em;">CPU 为了避免慢速的内存访问拖累指令的执行速度，一个常用的技巧是：将对cache或内存的<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">load</code>/<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">store</code>指令缓冲至 CPU 内部的 pipeline，对其（异步地）优化后再执行，如重排序(比如先执行命中 cache 的指令，或者将地址相近的指令放在一起执行) / 合并对同一地址的读或写 / 直接从 write buffer 中 load 数据等等，以尽量避免 cache miss，并减少对内存的访问。这是一个生产者消费者模型。</p>
<p style="margin: 0 0 1.1em;">此外，为了充分利用多级流水线，CPU 的 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">预测执行 speculative execution</code> 机制会根据以往的执行情况，在一个判断条件还没得到结果时预先执行概率大的分支并缓存结果，如果条件判断通过则直接使用该中间结果，这也会导致指令的乱序。</p>
<p style="margin: 0 0 1.1em;"><img alt="Alt text" class="en-media" longdesc="./1403925881122.png" name="21102672-fa20-41fd-889e-58c2eb93baf5" src="/assets/img/fd9868241dc03d1519b75f4ed3ad547b.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;">如图所示，CPU 的执行单元与 cache 之间还存在着各种 buffer，<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">load store</code>指令会先进入这些 buffer 中排队。当指令一旦被 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">flush</code> 到 cache ，MESI 缓存一致性协议将保证数据对所有 CPU 可见。</p>
</div><div>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;">3.2 什么情况允许<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Memory Reordering</code>？</h3>
<p style="margin: 0 0 1.1em;">CPU 进行 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Memory Reordering</code> 的前提是保证单线程下语义的正确性，这和编译器重排序遵循的规则是一样的。更进一步的，对于存在<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">数据依赖性</code>的指令不允许重排序。</p>
<p style="margin: 0 0 1.1em;">数据依赖分下列三种类型：</p>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li>写后读  <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">a = 1;b = a;</code>  写一个变量之后，再读这个位置。</li>
<li>写后写  <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">a = 1;a = 2;</code>  写一个变量之后，再写这个变量。</li>
<li>读后写  <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">a = b;b = 1;</code>  读一个变量之后，再写这个变量。</li>
</ol>
<p style="margin: 0 0 1.1em;">上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。</p>
<p style="margin: 0 0 1.1em;">对于存在<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">控制依赖性</code>的代码也可能发生重排序，如：</p>
</div><div>
<pre style="font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;" xml:space="preserve"><code style="font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;"><span style="color: #f92672;">if</span>(ready)
    b = a * a</code></pre>
<p style="margin: 0 0 1.1em;">假如对 ready 的 load 发生了 cache miss，为了不阻塞指令执行， CPU 可能会采用<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">猜测执行</code>的手段，预先 load a，并计算<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">a * a</code>的结果放入 buffer；待 ready 的 load 完成后，如果为 true，再将计算结果取出，执行 b 的 store 动作。</p>
</div><div>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;">3.3 CPU Memory Barrier</h3>
<p style="margin: 0 0 1.1em;">CPU 自身只能保证单线程下的serial 的语义，但在并发程序中，我们经常需要 <strong style="font-weight: bold;">保证多线程之间内存操作的有序性</strong>，这依赖我们手动在合适的地方插入内存屏障，禁止单线程内某种形式的重排序。</p>
<p style="margin: 0 0 1.1em;"><code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Load</code> <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Store</code> 两两组合，一共存在4种乱序，因此对应的有4种 barrier：</p>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li><code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">LoadLoad</code></li>
<li><code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">LoadStore</code></li>
<li><code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">StoreStore</code></li>
<li><p style="margin: 0 0 1.1em;"><code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">StoreLoad</code></p>
<p style="margin: 0 0 1.1em;"><code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">StoreLoad</code>乱序可能导致所谓的 <strong style="font-weight: bold;">可见性</strong> 问题，对同一个内存地址的访问，某些 CPU 在执行 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Load</code> 时允许直接从 StoreBuffer 中取其最近一次的 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Store</code> 返回，显然这可能导致拿到过时的数据；注意，前提是两次指令 <strong style="font-weight: bold;">访问同一个地址</strong>。 </p>
<p style="margin: 0 0 1.1em;">当前所有主流 CPU 对 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">StoreLoad barrier</code> 的实现都包括了其他3个 barrier 的效果（这不是必须的，只是现实如此），因此，<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">StoreLoad barrier</code> 通常也被当做 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Full Barrier</code> 使用。</p></li>
</ol>
<p style="margin: 0 0 1.1em;">使用标志位是不同的线程间进行通信的一种常见手段，此时需要借助 Memory Barrier 保证多线程间的有序性。一个简单的例子如下：</p>
</div><div>
<pre style="font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;" xml:space="preserve"><code style="font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;"><span style="color: #75715e;">// 初始状态</span>
a = <span style="color: #ae81ff;">0</span>;
ready = <span style="color: #f92672;">false</span>;

<span style="color: #75715e;">// Thread 1</span>
a = <span style="color: #ae81ff;">1</span>;
ready = <span style="color: #f92672;">true</span>;

<span style="color: #75715e;">// Thread 2</span>
<span style="color: #f92672;">if</span>(ready)
    <span style="color: #e6db74;">print</span> a  <span style="color: #75715e;">// 可能打印0</span>
<span style="color: #75715e;">/* 
或者：
c = ready
d = a; 
*/</span></code></pre>
<p style="margin: 0 0 1.1em;">在这个例子中，Thread 1试图用 ready 传递 a 已经被赋值的信号，但是存在两个问题：</p>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li>Thread 1 对 a 和 ready 的<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Store</code>动作有可能<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">StoreStore</code>乱序，导致 ready 为 true 时，Thread 2看到的 a 依然是0。因此，在 Thread 1 中必须在 a 和 ready 的store 动作之间插入 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">StoreStore barrier</code>，保证外部在看到 ready 为 true 时，a 必然已被修改；</li>
<li>即使 Thread 1 保证了 Store 有序，Thread 2 依然可能发生 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">LoadLoad</code> 乱序。对 a 的 Load 操作可能发生在 ready 的 Load 之前，因此下面的执行顺序是有可能的：</li>
</ol>
</div><div>
<pre style="font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;" xml:space="preserve"><code style="font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;">Thread <span style="color: #ae81ff;">1</span>                Thread <span style="color: #ae81ff;">2</span>
=========               ===========
                            Load <span style="color: #ae81ff;">a</span>  (<span style="color: #ae81ff;">0</span>)
<span style="color: #ae81ff;">a</span> = <span style="color: #ae81ff;">1</span>
&lt;StoreStore barrier&gt;
ready = <span style="color: #ae81ff;">true</span>
                            Load ready (<span style="color: #ae81ff;">true</span>)
                            判断通过
                            print <span style="color: #ae81ff;">a</span></code></pre>
<p style="margin: 0 0 1.1em;">因此，在 Thread 2 中必须用<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">LoadLoad barrier</code>保证 a 和 ready 两个 Load 动作的顺序性。</p>
<p style="margin: 0 0 1.1em;">由此可见，内存屏障 <strong style="font-weight: bold;">只能保证执行该屏障的 CPU 的内存顺序性</strong>，如果两个线程依赖读写某些相同变量进行通信，只在某一端使用屏障是不够的，另一端也必须根据自己的逻辑加上对应的内存屏障。</p>
</div><div>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;">3.4 硬件内存模型</h3>
<p style="margin: 0 0 1.1em;"><code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Memory Model</code>指定了 CPU 允许哪些指令重排序的发生，越多，内存一致性越弱；越少，内存一致性就越强。</p>
<p style="margin: 0 0 1.1em;"><img alt="Alt text" class="en-media" longdesc="./1403942010009.png" name="d0cb91ea-2429-4fbb-a241-85a67bea3aa6" src="/assets/img/3f85cd91f478831a157afc5179bccf2b.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;">常见的 x86 平台只允许 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">StoreLoad</code> 乱序，因此它的内存模型属于强一致性。</p>
<p style="margin: 0 0 1.1em;">不同平台上这四种 memory barrier 对应的指令如下，其中 x86 因为只支持<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">StoreLoad</code>乱序，所以只提供了<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">StoreLoad Barrier (亦即Full Barrier)</code>: <br/>
<img alt="Alt text" class="en-media" longdesc="./1403942922620.png" name="02590cd0-d583-4bc4-b7fd-f6fbd78c6c78" src="/assets/img/aaddce10fc3455e3fdc05bca8e83ff62.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
</div><div>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;">3.5 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Read-Acquire barrier</code> 和 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Write-Release barrier</code></h3>
<p style="margin: 0 0 1.1em;">在实际应用中，4种按乱序情况的分法太细粒度了，<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Read-Acquire barrier</code> 、 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Write-Release barrier</code> 是一种更粗粒度，也更常用的分类方式；</p>
<p style="margin: 0 0 1.1em;"><img alt="Alt text" class="en-media" longdesc="./1403943796180.png" name="8969be04-7e20-4a15-8b1c-743a04539398" src="/assets/img/41491455e62a0c75bf08d2d5c155ddc3.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;">即：</p>
<ul style="margin-top: 0; margin-bottom: 1.1em;"><li>Read-Acquire = LoadLoad + LoadStore;</li>
<li>Write-Release = LoadStore + StoreStore.</li>
</ul>
<p style="margin: 0 0 1.1em;"><code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Read-Acquire</code> <br/>
具有 Read-Acquire 语义的 Read 操作保证，所有后续的读写只有在该 Read 执行完毕后才能执行。</p>
<p style="margin: 0 0 1.1em;"><code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Write-Release</code> <br/>
具有 Write-Release 语义的 Write 操作保证，只有之前的所有读写都已经执行完毕，该 write 才能执行。</p>
<p style="margin: 0 0 1.1em;"><code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Read-Acquire barrier</code> 和 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Write-Release barrier</code> 总是成对使用的，<strong style="font-weight: bold;">保证不同线程间对内存操作的顺序性</strong>：</p>
<p style="margin: 0 0 1.1em;"><img alt="Alt text" class="en-media" longdesc="./1403959603491.png" name="c9a6da91-e94d-4935-87d2-44b713c9ab6b" src="/assets/img/43fe44f8dfcd17efb0a19880fd8d7c2d.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;">还是举上面的例子，用<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Read-Acquire</code>和<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Write-Release</code> barrier 的方式如下：</p>
</div><div>
<pre style="font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;" xml:space="preserve"><code style="font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;"><span style="color: #75715e;">// 初始状态</span>
a = <span style="color: #ae81ff;">0</span>;
ready = <span style="color: #f92672;">false</span>;

<span style="color: #75715e;">// Thread 1</span>
a = <span style="color: #ae81ff;">1</span>;
write_release_barrier();
ready = <span style="color: #f92672;">true</span>;

<span style="color: #75715e;">// Thread 2</span>
<span style="color: #f92672;">if</span>(ready){
    read_acquire_barrier();    
    print a
}</code></pre>
<p style="margin: 0 0 1.1em;">此时，我们 <strong style="font-weight: bold;">为 ready 这个变量赋予了 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Read-Acquire</code> 和 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Write-Release</code> 语义</strong>，对它的读或写动作与前后的其他 load/store 动作确立了先后关系. 当 Thread 2 发现 ready 为 true 时，a 的 store 必然已经完成，必然为1; 而 a 的 load 也不会比 ready 的 load 先完成.</p>
<p style="margin: 0 0 1.1em;"><code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Read-Acquire</code> 和 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Write-Release</code> 语义也被广泛应用在锁的实现中，<strong style="font-weight: bold;">加锁 和 释放锁 分别附带了<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Read-Acquire</code> 和 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Write-Release</code> 语义，保证了 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">加锁 --&gt; load/store</code> 和 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">load/store --&gt; 释放锁</code> 这两个指令序列之间的偏序关系</strong>，这样当某个线程获取了锁时，它可以确信前一个线程在释放锁之前所做的操作已经全部完成了。</p>
<p style="margin: 0 0 1.1em;">接下来会看到，<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Read-Acquire</code> 和 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Write-Release</code> 是 JMM 的核心。</p>
</div><div>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;">3.6 JMM 对 CPU Memory Reordering 的规则</h3>
<p style="margin: 0 0 1.1em;">JMM 定义了单线程内必须遵循如下重排序规则：</p>
<table style="border-collapse: collapse; border-spacing: 0; margin-bottom: 20px;">
<thead>
<tr>
<th style="padding: .5em; line-height: 1.5; vertical-align: bottom; border-top: 0; font-weight: bold; border: 1px solid #ddd;">NormalLoad</th>
<th align="center" style="padding: .5em; line-height: 1.5; vertical-align: bottom; border-top: 0; font-weight: bold; border: 1px solid #ddd;">NormalStore</th>
<th align="center" style="padding: .5em; line-height: 1.5; vertical-align: bottom; border-top: 0; font-weight: bold; border: 1px solid #ddd;">VolatileLoad / MonitorEnter</th>
<th align="center" style="padding: .5em; line-height: 1.5; vertical-align: bottom; border-top: 0; font-weight: bold; border: 1px solid #ddd;">VolatileStore / MonitorExit</th>
</tr>
</thead>
<tbody><tr>
<td style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;">NormalLoad</td>
<td align="center" style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;"></td>
<td align="center" style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;"></td>
<td align="center" style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;"></td>
</tr>
<tr>
<td style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;">NomalStore</td>
<td align="center" style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;"></td>
<td align="center" style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;"></td>
<td align="center" style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;"></td>
</tr>
<tr>
<td style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;">VolatileLoad / MonitorEnter</td>
<td align="center" style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;">LoadLoad</td>
<td align="center" style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;">LoadStore</td>
<td align="center" style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;">LoadLoad</td>
</tr>
<tr>
<td style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;">VolatileStore / MonitorExit</td>
<td align="center" style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;"></td>
<td align="center" style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;"></td>
<td align="center" style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;"><code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">StoreLoad</code></td>
</tr>
</tbody></table>
<p style="margin: 0 0 1.1em;">看上去很复杂，但其实只有两点：</p>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li><p style="margin: 0 0 1.1em;"><em>* <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Volatile</code> 变量 / <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Monitor</code>具有 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Read-Acquire &amp; Write-Release</code> 语义； *</em></p>
<p style="margin: 0 0 1.1em;">第三行即 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Read-Acquire</code>，最后一列即 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Write-Release</code>；</p></li>
<li><p style="margin: 0 0 1.1em;"><em>* 在任意两个 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Volatile</code> 变量 / <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Monitor</code> 的 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Store-&gt;Load</code> / <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Exit-&gt;Enter</code> 操作中间必须插入一个 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">StoreLoad</code> barrier 禁止重排序; 这同时也解决了单个 volatile 变量 / Monitor 可能出现的可见性问题 。*</em></p>
<p style="margin: 0 0 1.1em;">可见性问题已经在3.3描述过了.</p></li>
</ol>
<p style="margin: 0 0 1.1em;"><img alt="Alt text" class="en-media" longdesc="./1403963190097.png" name="b09cfb74-f1f3-43c7-9cd4-589f12e443f9" src="/assets/img/76c4cf48eb5fc3fc8f6dde0593ee85ef.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;">JMM cookbook 中提到了一种可能的实现。编译器很多时候无法知道确切的<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Load</code> / <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Store</code> 指令顺序，比如在一个方法 return 之前对一个 Volatile 变量 write 了，因此一个策略是采取悲观策略，在每个可能需要禁止某种重排序的地方都加上对应的 barrier：</p>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li>在每个 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Volatile Read / Monitor Enter</code> 后加上 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">LoadLoad</code> &amp; <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">LoadStore</code> barrier，亦即 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Read-Acquire</code> barrier;</li>
<li>在每个 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Volatile Write / Monitor Exit</code> 前加上 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">StoreStore</code> &amp; <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">LoadStore</code> barrier，亦即 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Write-Release</code> barrier;</li>
<li>在每个 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Volatile Write / Monitor Exit</code> 后加上 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">StoreLoad</code> barrier（也可以在每次 Read 前加上，但 Write 出现的几率显然要低的多）。</li>
</ol>
<p style="margin: 0 0 1.1em;">当然，编译器会做许多别的优化，比如合并 barrier 之类的，而且很大一部分的 barrier 对应到硬件指令时是空操作。</p>
<p style="margin: 0 0 1.1em;">这个策略在 openjdk 的 C1 编译器<a href="https://www.evernote.com/OutboundRedirect.action?dest=https%3A%2F%2Fcode.google.com%2Fp%2Fneedle%2Fsource%2Fbrowse%2Fsrc%2Fshare%2Fvm%2Fc1%2Fc1_LIRGenerator.cpp%3Fr%3D2f644f85485d7460dea5edb5f6c8716093e66a44" style="background: transparent; color: #1980e6; text-decoration: none;" target="_blank"> (c1_LIRGenerator.cpp) </a>中得到了印证：</p>
</div><div>
<pre style="font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;" xml:space="preserve"><code style="font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;"><span style="color: #75715e;">//------------------------field access--------------------------------------</span>

<span style="color: #75715e;">// Comment copied form templateTable_i486.cpp</span>
<span style="color: #75715e;">// ----------------------------------------------------------------------------</span>
<span style="color: #75715e;">// Volatile variables demand their effects be made known to all CPU's in</span>
<span style="color: #75715e;">// order.  Store buffers on most chips allow reads &amp; writes to reorder; the</span>
<span style="color: #75715e;">// JMM's ReadAfterWrite.java test fails in -Xint mode without some kind of</span>
<span style="color: #75715e;">// memory barrier (i.e., it's not sufficient that the interpreter does not</span>
<span style="color: #75715e;">// reorder volatile references, the hardware also must not reorder them).</span>
<span style="color: #75715e;">//</span>
<span style="color: #75715e;">// According to the new Java Memory Model (JMM):</span>
<span style="color: #75715e;">// (1) All volatiles are serialized wrt to each other.</span>
<span style="color: #75715e;">// ALSO reads &amp; writes act as aquire &amp; release, so:</span>
<span style="color: #75715e;">// (2) A read cannot let unrelated NON-volatile memory refs that happen after</span>
<span style="color: #75715e;">// the read float up to before the read.  It's OK for non-volatile memory refs</span>
<span style="color: #75715e;">// that happen before the volatile read to float down below it.</span>
<span style="color: #75715e;">// (3) Similar a volatile write cannot let unrelated NON-volatile memory refs</span>
<span style="color: #75715e;">// that happen BEFORE the write float down to after the write.  It's OK for</span>
<span style="color: #75715e;">// non-volatile memory refs that happen after the volatile write to float up</span>
<span style="color: #75715e;">// before it.</span>
<span style="color: #75715e;">//</span>
<span style="color: #75715e;">// We only put in barriers around volatile refs (they are expensive), not</span>
<span style="color: #75715e;">// _between_ memory refs (that would require us to track the flavor of the</span>
<span style="color: #75715e;">// previous memory refs).  Requirements (2) and (3) require some barriers</span>
<span style="color: #75715e;">// before volatile stores and after volatile loads.  These nearly cover</span>
<span style="color: #75715e;">// requirement (1) but miss the volatile-store-volatile-load case.  This final</span>
<span style="color: #75715e;">// case is placed after volatile-stores although it could just as well go</span>
<span style="color: #75715e;">// before volatile-loads.</span>

<span style="color: #75715e;">// volatile store</span>
<span style="color: #ae81ff;">void</span> LIRGenerator<span style="color: #f8f8f2;">::do_StoreField</span>(StoreField<span style="color: #e6db74;">*</span> x) {
    <span style="color: #75715e;">// Write-Release barrier</span>
    <span style="color: #f92672;">if</span> (is_volatile <span style="color: #e6db74;">&amp;&amp;</span> os<span style="color: #f8f8f2;">::is_MP</span>()) {
        __ membar_release();
    }

    <span style="color: #75715e;">// Store</span>
    <span style="color: #f92672;">...</span>
    volatile_field_store(value<span style="color: #e6db74;">.</span>result(), address, info);
    <span style="color: #f92672;">...</span>

    <span style="color: #75715e;">// StoreLoad barrier，这里直接写作 membar 的原因是大部分平台上 storeload barrier 被实现为一个 full barrier</span>
    <span style="color: #f92672;">if</span> (is_volatile <span style="color: #e6db74;">&amp;&amp;</span> os<span style="color: #f8f8f2;">::is_MP</span>()) {
        __ membar();
    }
}

<span style="color: #75715e;">// volatile load</span>
<span style="color: #ae81ff;">void</span> LIRGenerator<span style="color: #f8f8f2;">::do_LoadField</span>(LoadField<span style="color: #e6db74;">*</span> x) {
    <span style="color: #75715e;">// Load</span>
    <span style="color: #f92672;">...</span>
    volatile_field_load(address, reg, info);
    <span style="color: #f92672;">...</span>

    <span style="color: #75715e;">// Read-Acquire barrier</span>
    <span style="color: #f92672;">if</span> (is_volatile <span style="color: #e6db74;">&amp;&amp;</span> os<span style="color: #f8f8f2;">::is_MP</span>()) {
        __ membar_acquire();
    }
}
</code></pre>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">3. JMM的其他方面</h2>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li><strong style="font-weight: bold;">原子性</strong>，JMM 规定基本类型的 load/store 必须是原子的；</li>
<li><code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Volatile</code> 变量不允许使用寄存器分配。</li>
<li>final 变量??</li>
</ol>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">4. 总结</h2>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li><code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">volatile</code>的作用：<strong style="font-weight: bold;">保证线程A的内存操作被线程B观察时，是有序的</strong>。单线程内，编译器、CPU会出于各种原因乱序<em>完成</em>指令，虽然本线程内的逻辑依然是正确的，但外部线程观察到的指令生效的顺序不可保证，<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">volatile</code>就是解决这个问题的。</li>
<li>什么时候用<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">volatile</code>? –  当一个变量被多线程访问, 且会被其中某些线程 write 时, 用<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">volatile</code>.</li>
</ol>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">5. 参考资料</h2>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li><a href="http://gee.cs.oswego.edu/dl/jmm/cookbook.html" style="background: transparent; color: #1980e6; text-decoration: none;" target="_blank">The JSR-133 Cookbook</a></li>
<li>何登成的《CPU Cache and Memory Ordering.ppt》</li>
<li><a href="http://docs.google.com/presentation/d/1JkOUQ07nr0WQ8SKqcWA5D3M0v1gUdAwgNBbUcMhhGis/preview?usp=sharing&amp;sle=true#slide=id.p" style="background: transparent; color: #1980e6; text-decoration: none;" target="_blank">无锁化编程</a></li>
<li><a href="http://preshing.com/20120913/acquire-and-release-semantics" style="background: transparent; color: #1980e6; text-decoration: none;" target="_blank">Acquire and Release Semantics</a></li>
<li><a href="http://preshing.com/20120625/memory-ordering-at-compile-time/" style="background: transparent; color: #1980e6; text-decoration: none;" target="_blank">Memory Ordering at Compile Time</a></li>
<li><a href="http://ifeve.com/memory-barriersfences/" style="background: transparent; color: #1980e6; text-decoration: none;" target="_blank">Memory Barriers/Fences</a></li>
<li><a href="http://gvsmirnov.ru/blog/tech/2014/02/10/jmm-under-the-hood.html#printassembly-fun" style="background: transparent; color: #1980e6; text-decoration: none;" target="_blank">Java Memory Model Under The Hood</a></li>
<li><a href="http://www.linuxjournal.com/article/8212" style="background: transparent; color: #1980e6; text-decoration: none;" target="_blank">Memory Ordering in Modern Microprocessors, Part II</a></li>
<li><a href="http://ifeve.com/cpu-cache-flushing-fallacy-cn/" style="background: transparent; color: #1980e6; text-decoration: none;" target="_blank">CPU Cache Flushing Fallacy</a></li>
<li><a href="http://preshing.com/20120930/weak-vs-strong-memory-models/" style="background: transparent; color: #1980e6; text-decoration: none;" target="_blank">Weak vs. Strong Memory Models</a></li>
<li><a href="http://www.infoq.c/java-memory-model-1" style="background: transparent; color: #1980e6; text-decoration: none;" target="_blank">深入理解Java内存模型</a> 系列文章</li>
</ol>
<hr style="-moz-box-sizing: content-box; box-sizing: content-box; height: 0; margin-top: 21px; margin-bottom: 21px; border: 0; border-top: 1px solid rgba(102,128,153,0.1); margin: 2em 0;"/>
<p style="margin: 0 0 1.1em;">附：<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">StoreLoad</code> 乱序导致 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Peterson 算法</code> 失效 <br/>
这不属于通用问题，而是依赖代码的逻辑。</p></div><div></div></div>