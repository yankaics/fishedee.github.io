---
layout: post
category: 后端
---

# 1 概述
后端rpc架构

# 2 服务注册与发现
go-micro,etcd,zookeeper

# 3 服务选择
selector

# 4 编码与解码
codec

# 5 监控
metrics,rate

# 6 目标

## 6.1 问题
 
* 所有服务放在单个进程跑，无法很好地监控每个服务的运行情况，cpu，内存和调用时间
* 所有服务都放在本机上，无法实现分布式运行，和容错处理，希望能实现服务的分离部署，自动负载均衡。
* 单机迁移为分布式的成本尽可能简单与透明
* 单个服务的测试尽可能简单
* 单独调试一个服务尽可能简单。

## 6.2 设计

* 框架支持开启rpc与不开启rpc模式
* 不开启rpc模式时，就像普通的beego框架一样
* 开启rpc模式时，model下的一个文件夹为一个服务，包名作为服务名。启动后，以所在的包名作为服务名，将服务名与启动IP写入到注册中心区。要注意的是，rpc启动时需要指定为两种，启动主服务（路由），启动模型层服务，默认为同时启动所有服务，也就是在单机上实现rpc模式。

入口进程会监控下方的多个子进程。关闭时同时关掉所有的子进程，启动时根据子进程的依赖顺序来启动，运行时监控子进程的运行情况，子进程崩溃时自动重启。

非rpc模式与rpc模式，都加入模型层服务的调用时间统计。异常需要支持跨服务的传递。

## 6.3 faq

* rpc需要写idl文件么? 

不需要，需要的话跟原来的单机编写有比较大的差距，由fishgen根据代码来生成接口即可。造成单机代码迁移为分布式代码的成本过高。

* 模型层服务支持直接的http访问么

支持，模型层的本质就是一个http2的post的json服务。这样能简单迅速地让php，python的控制层接入到服务中。

# 7 目标2

## 7.1 问题
由于原框架同时整合了通信，ioc，数据库，cache等模块，模块之间的耦合严重，导致框架中各个模块难以被单独地使用，而且使用ioc时总有一种莫名其妙就实现了的感觉。希望框架做的事情更透明更简单。

## 7.2 设计

```
type LoginAo struct{
	Init func()
	IsLogin func(ctx *Context) bool
	CheckMustLogin func(ctx *Context)
}

type loginAo struct{
}

func (this *loginAo) Init(){
}

func (this *loginAo) IsLogin(ctx *Context) bool {
	return true
}

func (this *loginAo) CheckMustLogin(ctx *Context) {
}

func init(){
	a := &loginAo{}
	RegisterService(LoginAo{
		Init:a.Init,
		IsLogin:a.IsLogin,
		CheckMustLogin:a.CheckMustLogin,
	})
}
```

定义服务

```
func main(){
	var a LoginAo
	err := InitService(&a)
	if err != nil{
		panic(err)
	}
	a.IsLogin(&Context{})
}
```

使用服务

```
type LoginAo2 struct{
	Init func()
	IsLogin func(ctx *Context) bool
	CheckMustLogin func(ctx *Context)
}

type loginAo2 struct{
	db DB
	log Log
	loginAo LoginAo
}

func (this *loginAo2) Init(){
	this.db,err = NewDB()
	if err != nil{
		panic(err)
	}
	this.log,err = NewLog()
	if err != nil{
		panic(err)
	}
	err = InitService(&this.loginAo)
	if err != nil{
		panic(err)
	}
}

func (this *loginAo2) IsLogin(ctx *Context) bool {
	this.log.Debug("%v","123")
	return this.loginAo.IsLogin(ctx)
}

func (this *loginAo2) CheckMustLogin(ctx *Context) {
	this.log.Debug("%v",456)
	this.loginAo.CheckMustLogin(ctx)
}

func init(){
	a := &loginAo2{}
	RegisterService(LoginAo2{
		Init:a.Init,
		IsLogin:a.IsLogin,
		CheckMustLogin:a.CheckMustLogin,
	})
}
```

服务嵌套

```
type loginController struct{
	loginAo2 LoginAo2
}

func (this *loginController) Init(){
	err := InitService(&this.loginAo2)
	if err != nil{
		panic(err)
	}
}

func (this *loginController) IsLogin_Json() bool{
	return this.loginAo2.IsLogin(this.Ctx)
}

func (this *loginController) CheckMustLogin_Json() interface{}{
	this.loginAo2.CheckMustLogin()
	return nil
}

func (this *loginController) AutoRender(data interface{},viewname string){
	data,err := json.Marshal(data)
	if err != nil{
		panic(err)
	}
	this.Ctx.Write(data)
}

func init(){
	InitRoute("dd",&loginController{})
}
```

控制器与路由，这个是额外的演示写法，严格来说不属于micro-service框架的一部分

问题

* 错误怎么处理
* 配置怎么共用


