---
layout: post
category: 后端
---

# 1 概述
分布式数据原理

# 2 ACID,CAP与BASE

## 2.1 概述
提到分布式数据，无人不会提及到大名鼎鼎的ACID原则，CAP原理，与BASE原则

## 2.2 ACID
ACID,指数据库事务正确执行的四个基本要素的缩写。包含：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。一个支持事务（Transaction）的数据库，必需要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性，交易过程极可能达不到交易方的要求。

* 原子性（Atomicity），一个事务要么全部执行,要么不执行
* 一致性（Consistency），事务的运行并不改变数据库中数据的一致性
* 隔离性（Isolation），两个以上的事务不会出现交错执行的状态
* 持久性（Durability)，事务执行成功以后,该事务所对数据库所作的更改便是持久的保存在数据库之中，不会无缘无故的回滚

不知道你是第一次看这四个名词是什么感觉，反正我第一次看的时候感觉就是，好像有点明白，又好像有点不明白。我们重新来推导一下这四个特性，想象一下最开始的数据库连上面一个特性都没有。

### 2.2.1 简陋数据库

```
update t_user set name = 'fish1' where userId = 10001
``` 

我用客户端执行了上面一条sql，然后机器突然断电了。

```
select * from t_user where userId = 10001
```

重启机器后，我执行上面那条查询语句，发现userId=10001的name为fish，而不是我最后一次输入的fish1！

这是因为数据库在执行完update操作后，竟然没有调用file的sync，让数据强制写落到磁盘上，而是只缓存到内存中，导致数据库掉电后重启造成事务丢失。所以，数据库的第一个要求特性是持久性（Durability)，让每个事务执行后都必须落地磁盘，保证即使机器掉电后数据也不会丢失。

### 2.2.2 D数据库

```
update t_user set money = money + 100 where userId = 10002
update t_user set money = money - 100 where userId = 10001
``` 

我用客户端执行了上面的一条sql，目的是让10001用户转钱给10002用户100元。很不幸的是，在执行完了第一条sql后，机器又断电了。

```
select * from t_user where userId = 10001
select * from t_user where userId = 10002
```

重启机器后，我执行上面那条查询语句，发现10002用户多了100元，而10002用户仍然是保持原值，没有增加100元！

我查，这是多么恶心的事情简直不能忍！数据库应该是要么10001用户少100，同时10002用户多100，要么是都不变，怎么会有个中间状态。所以，数据库的第二个要求特性是原子性（Atomicity），事务要么是全部提交的，要么是全部不提交的，这部分数据库是用日志来实现的。

```
start trasiaction
update t_user set money = money - 100 where userId = 10001
update t_user set money = money + 100 where userId = 10002
end trasiaction
```

在这以后，我们提交sql是这么提交的，通过start trasiaction告诉数据库这两条sql连起来是一个事务。

### 2.2.3 AD数据库

```
start trasiaction
update t_user set money = money + 100 where userId = 10002
update t_user set money = money - 100 where userId = 10001
end trasiaction
```

我依然用客户端执行了上面的一条sql，目的是让10001用户转钱给10002用户100元。很不幸的是，在执行完了第一条sql后，机器又断电了。

```
select * from userId = 10002
```

与此同时，10002的用户在自己家不断调用上面的sql语句，来查询自己有多少钱。我重启机器后，由于Atomicity特性，10002用户的数据回滚了。10002用户在家看到自己的钱突然多了100元，而后又少了100元。他空欢喜了一场，然后投诉我们公司，为什么给了自己100元，然后又突然抽走，他甚至还截图了自己多了100元数据的页面！

为了避免这种恶心的情况，数据库的第三个要求特性是一致性(Consistency)，数据库只能看到提交后事务的数据，不能看到事务操作过程中处于不一致状态的数据。这部分数据库使用MVCC机制来实现的。

### 2.2.4 ACD数据库

```
start trasiaction
select * from t_user where userId = 10001
update t_user set money = money - 100 where userId = 10001 
update t_user set money = money + 100 where userId = 10002
end trasiaction
```

```
start trasiaction
select * from t_user where userId = 10001
update t_user set money = money - 100 where userId = 10001 
update t_user set money = money + 100 where userId = 10003
end trasiaction
```

我们进入了现实中，其实转钱前是需要查询用户够不够钱的，不够钱的话，是不会执行update操作的。所以，在sql前我加上了select操作。问题来了，我们需求是用户10001需要向10002与10003用户各转100元的，当然10001用户只有120元的情况下，他会成功么。答案是，他有可能会成功！

```
#事务1
select * from t_user where userId = 10001
#事务2
select * from t_user where userId = 10001
#事务1
update t_user set money = money - 100 where userId = 10001 
update t_user set money = money + 100 where userId = 10002
#事务2
update t_user set money = money - 100 where userId = 10001 
update t_user set money = money + 100 where userId = 10003
```

当两个事务按着上面的顺序交叉执行时，只有120元的10001用户竟然是可以向10002与10003用户各转100元的！

所以，数据库的第四个要求特性是隔离性（Isolation），事务间应该有隔离，如果他们有数据冲突，应该进行上锁操作的。

```
start trasiaction
select * from t_user where userId = 10001 for update
update t_user set money = money - 100 where userId = 10001 
update t_user set money = money + 100 where userId = 10002
end trasiaction
```

```
start trasiaction
select * from t_user where userId = 10001 for update
update t_user set money = money - 100 where userId = 10001 
update t_user set money = money + 100 where userId = 10003
end trasiaction
```

最终，我们的sql加上了for update操作，告诉mysql，我是要对10001用户的数据进行上锁的，其他并发事务要过来的话只能先等我执行完毕了。

#### 2.2.5 ACID数据库
至此，我们用了转钱的例子，来证明了ACID的每个特性都是多么必要的，不然会导致后果很严重的金钱问题。数据不一致，钱转多了，或者转少了。最后，总结一下ACID特性

* 原子性（Atomicity），强调写一致，要么全部完成，要么全部不完成。
* 一致性（Consistency），强调读一致，只能看到已经提交的事务数据。
* 隔离性（Isolation），强调并发一致，即使事务是并发执行的，数据也不会造成不一致。
* 持久性（Durability)，强调可靠，只要事务提交了，就不会丢失数据。

## 2.3 CAP

### 2.3.1 概述
在一个CAP分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。

* 一致性（Consistency）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）
* 可用性（Availability）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）
* 分区容忍性（Partition tolerance）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。

CAP原理就像是能量守恒定律一样，给那些想实现永动机，和想实现分布式ACID的人们当头一棒，这是不可能的！

### 2.3.2 分区容忍性
系统要么是分布式的，要么是单机的。

### 2.3.3 一致性
这个一致性和ACID的一致性不同，这个一致性是**单个操作**的一致性，而不是**单个事务**（多个操作）的一致性。分布式的一致性有以下几种：

* 强一致性。在更新完成后，（A、B或C进行的）任何后续访问都将返回更新过的值。
* 弱一致性。系统不保证后续访问将返回更新过的值。
* 最终一致性。存储系统保证如果对象没有新的更新，最终（在不一致窗口关闭之后）所有访问都将返回最后更新的值。

注意，弱一致性中包含着最终一致性的范围。

### 2.3.4 可用性
在分布式环境下，有N台机器

* 高可用，N-1台机器都当机了，仍然可以对外服务。
* 低可用，1太机器当机了，就不能对外服务。

### 2.3.5 直观
关于CAP的通俗理解，《七周七数据库》中有一个通俗的理解。

如果世界上有四个人ABCD，另外有一个健忘的人E，ABCD是与世隔绝的，E是个杰伦迷，偶尔会告诉ABCD其中一个人杰伦的最新专辑是什么，偶尔也会问ABCD其中一个关于杰伦的最新专辑是什么。

* CA系统，ABCD四个人聚在一起生活，E无论什么告诉，ABCD都会同时知道，所以E问ABCD其中一个人时，他们都会告诉E一个准确的答案。
* AP系统，ABCD四个人现在分开了。但他们约定，如果E告诉他们任何一个人关于杰伦的信息，他都会先打电话给其他人通知这个消息，在确保所有人都收到后，他才会告诉E他听到了。这种情况下，E后来无论问哪个人，数据都是准确的。由于并不是所有人的电话都能打通，所以E的每次询问并不一定会有反应。
* CP系统，ABCD四个人现在分开了。但他们约定，如果E告诉他们任何一个人关于杰伦的信息，他都会先确定他收到了，然后再打电话给其他人通知这个消息。这种情况下，E可能会收到一些过期的杰伦信息。

### 2.3.6 总结
CAP原理看起来是个绝望的结论，但它其实并没有限制构造这样的系统：

* CP系统，强一致性+基本可用性，即使当掉了N/2-1台机器，仍然可以对外提供一致性服务。
* AP系统，最终一致性+高可用性，即使当掉了N-1台机器，仍然可以对外服务，但是数据可能是不一致的，只保证经过一段时间窗口后，数据是最终一致的。

![](/assets/img/14583701507326.jpg)

所以，根据CAP的原理的不同抉择，以及对不同场景下的数据需求，nosql的数据库建立了许多不同模型下的数据库。

# 3 伸缩性
怎样实现数据在多台机器中透明伸缩，这是个好问题。

## 3.1 哈希

![](/assets/img/14591678133905.jpg)

将数据放在多台机器上，以userId为key直接哈希到对应的数据库上。

* 优点是开发简单，易维护
* 缺点是伸缩困难，例如从3台机器伸缩到5台机器的时候，由于哈希的值变化大，3与4的最小公倍数为12，也就是每12个数值下只有3个数值是放在自己的原机器，其他9个数值需要迁移到其他机器上。增加25%的机器数量，导致了75%的数据需要迁移。数据的迁移比例与增加的机器比例太高，导致迁移数据的速度超级慢，无法达成透明迁移。所以，一般只会使用倍数迁移法。2台->4台->8台这样的迁移。

## 3.2 一致性哈希

### 3.2.1 环形哈希

![](/assets/img/14591690103903.jpg)

首先我们引入有4个key的环

![](/assets/img/14591690422168.jpg)

每台机器在环上任意取三个点，然后key以顺时针的方式在环上找到的第一个节点作为该节点的哈希值。

### 3.2.2 迁移成本

![](/assets/img/14591692980761.jpg)
当B节点数据需要摘除时，只有A节点与B节点间的数据需要迁移到C节点，而其他节点的数据不需要迁移。

![](/assets/img/14591693631574.jpg)
当B与C节点之间新增一个新节点的时候，只有B与C之间的一部分数据需要迁移，其他数据不迁移。

### 3.2.3 虚拟节点

![](/assets/img/14591686829692.jpg)

但是，当节点数量比较少时，直接的环形哈希会容易导致数据分布不平衡，相当多的数据被扔到一台机器上。解决办法很简单，引入一个虚拟层，将单个实体节点对应到N个虚拟节点上。这样当增加一台机器时，会增加N多的虚拟节点，大概均衡地将数据切成N份，导致原来的机器的数据能平均地迁移一小部分数据到这台新机器上了。这样大大地降低了迁移的成本，而且保证数据均衡分布。

以上，我们都是假设每个数据key对应的data是大致均等的，所以用了一致性哈希后，由于均衡分布了key，所以也均衡分布了data。但是如果，每个key对应的data是差异很大的，或者每台机器上的容量也是差异很大的，这得怎么做data的均衡分布呢？

## 3.3 一致性哈希meta+数据库

![](/assets/img/14591709129850.jpg)

hdfs中采用了一致性哈希+数据库的方式做二级映射，数据存放在namenode与datanode两个位置，namenode存放数据的meta列表，即datanode的块数，与每块所在的机器位置，而datanode则存放数据的具体信息。当需要寻找key所在的数据时，先用一致性哈希来寻找key所在的namenode，然后在namenode中的数据库返回该key的datanode信息，再到datanode指定的机器取出来data，合并起来即可。

这样即使每个key对应的value是变长的，也会因为二级映射的方式变得均衡分布。

## 3.4 总结

分布式的高伸缩性主要要解决的问题是：

1. 数据的均衡分布，直接哈希，虚拟节点，meta分布。
2. 数据的透明迁移，环形哈希，数据库映射。

# 4 可用性
现在数据的确是分布到多个机器上，而且负载均衡了，但是，如果其中一台机器崩掉了，怎么办？怎样做到即使崩掉了一两台机器，系统仍然可以无损地对外服务？

## 4.1 单写

* 强同步
* 半同步
* 异步

## 4.2 多写

NWR和向量时钟

## 4.3 故障恢复

* paxos或raft
* dns，负载均衡恢复

# 6 事务

## 6.1 单机事务

## 6.2 队列

## 6.3 乐观锁

## 6.4 幂等

## 6.5 二阶段提交

http://hedengcheng.com/?p=892


